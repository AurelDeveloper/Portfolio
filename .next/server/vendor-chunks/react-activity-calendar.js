/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-activity-calendar";
exports.ids = ["vendor-chunks/react-activity-calendar"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-activity-calendar/build/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-activity-calendar/build/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("'use client';\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar chroma = __webpack_require__(/*! chroma-js */ \"(ssr)/./node_modules/chroma-js/chroma.js\");\nvar dateFns = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/index.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }\n\nvar chroma__default = /*#__PURE__*/_interopDefault(chroma);\nvar React__default = /*#__PURE__*/_interopDefault(React);\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nconst NAMESPACE = 'react-activity-calendar';\nconst LABEL_MARGIN = 8; // px\n\nconst DEFAULT_MONTH_LABELS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\nconst DEFAULT_LABELS = {\n  months: DEFAULT_MONTH_LABELS,\n  weekdays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  totalCount: '{{count}} activities in {{year}}',\n  legend: {\n    less: 'Less',\n    more: 'More'\n  }\n};\n\nfunction useColorScheme() {\n  const [colorScheme, setColorScheme] = React.useState('light');\n  const onChange = event => setColorScheme(event.matches ? 'dark' : 'light');\n  React.useEffect(() => {\n    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n    setColorScheme(mediaQuery.matches ? 'dark' : 'light');\n    mediaQuery.addEventListener('change', onChange);\n    return () => {\n      mediaQuery.removeEventListener('change', onChange);\n    };\n  }, []);\n  return colorScheme;\n}\n\nconst query = '(prefers-reduced-motion: reduce)';\nfunction usePrefersReducedMotion() {\n  const [prefersReducedMotion, setPrefersReducedMotion] = React.useState(true);\n  React.useEffect(() => {\n    const mediaQuery = window.matchMedia(query);\n    setPrefersReducedMotion(mediaQuery.matches);\n    const onChange = event => {\n      setPrefersReducedMotion(event.matches);\n    };\n    mediaQuery.addEventListener('change', onChange);\n    return () => {\n      mediaQuery.removeEventListener('change', onChange);\n    };\n  }, []);\n  return prefersReducedMotion;\n}\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".styles-module_container__GBNxC {\\n  width: max-content; /* Calendar should not grow */\\n  max-width: 100%; /* Do not remove - flexbox parents */\\n  display: flex;\\n  flex-direction: column;\\n  gap: 8px;\\n}\\n\\n.styles-module_container__GBNxC rect {\\n  stroke: rgba(0, 0, 0, 0.08);\\n  stroke-width: 1px;\\n  shape-rendering: geometricPrecision;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  .styles-module_container__GBNxC rect {\\n    stroke: rgba(255, 255, 255, 0.04);\\n  }\\n}\\n\\n.styles-module_scrollContainer__-bJC8 {\\n  max-width: 100%;\\n  overflow-x: auto;\\n  overflow-y: hidden;\\n}\\n\\n.styles-module_calendar__sT1ND {\\n  display: block; /* SVGs are inline-block by default */\\n  overflow: visible; /* Weekday labels are rendered left of the container */\\n}\\n\\n.styles-module_calendar__sT1ND text {\\n  fill: currentColor;\\n}\\n\\n.styles-module_footer__ZQ-Bl {\\n  display: flex;\\n  flex-wrap: wrap;\\n  gap: 4px 16px;\\n  white-space: nowrap;\\n}\\n\\n.styles-module_legendColors__kFY2e {\\n  margin-left: auto;\\n  display: flex;\\n  align-items: center;\\n  gap: 3px;\\n}\\n\\n@keyframes styles-module_loadingAnimation__V0w3h {\\n  0% {\\n    fill: var(--react-activity-calendar-loading);\\n  }\\n  50% {\\n    fill: var(--react-activity-calendar-loading-active);\\n  }\\n  100% {\\n    fill: var(--react-activity-calendar-loading);\\n  }\\n}\\n\";\nvar styles = {\"container\":\"styles-module_container__GBNxC\",\"scrollContainer\":\"styles-module_scrollContainer__-bJC8\",\"calendar\":\"styles-module_calendar__sT1ND\",\"footer\":\"styles-module_footer__ZQ-Bl\",\"legendColors\":\"styles-module_legendColors__kFY2e\",\"loadingAnimation\":\"styles-module_loadingAnimation__V0w3h\"};\nstyleInject(css_248z);\n\nfunction groupByWeeks(activities, weekStart = 0 // 0 = Sunday\n) {\n  if (activities.length === 0) {\n    return [];\n  }\n  const normalizedActivities = fillHoles(activities);\n\n  // Determine the first date of the calendar. If the first date is not the\n  // set start weekday, the selected weekday one week earlier is used.\n  const firstDate = dateFns.parseISO(normalizedActivities[0].date);\n  const firstCalendarDate = dateFns.getDay(firstDate) === weekStart ? firstDate : dateFns.subWeeks(dateFns.nextDay(firstDate, weekStart), 1);\n\n  // To correctly group activities by week, it is necessary to left-pad the list\n  // because the first date might not be set start weekday.\n  const paddedActivities = [...Array(dateFns.differenceInCalendarDays(firstDate, firstCalendarDate)).fill(undefined), ...normalizedActivities];\n  const numberOfWeeks = Math.ceil(paddedActivities.length / 7);\n\n  // Finally, group activities by week\n  return Array(numberOfWeeks).fill(undefined).map((_, weekIndex) => paddedActivities.slice(weekIndex * 7, weekIndex * 7 + 7));\n}\n\n/**\n * The calendar expects a continuous sequence of days,\n * so fill gaps with empty activity data.\n */\nfunction fillHoles(activities) {\n  const dateMap = {};\n  for (const activity of activities) {\n    dateMap[activity.date] = activity;\n  }\n  return dateFns.eachDayOfInterval({\n    start: dateFns.parseISO(activities[0].date),\n    end: dateFns.parseISO(activities[activities.length - 1].date)\n  }).map(day => {\n    const date = dateFns.formatISO(day, {\n      representation: 'date'\n    });\n    if (dateMap[date]) {\n      return dateMap[date];\n    }\n    return {\n      date,\n      count: 0,\n      level: 0\n    };\n  });\n}\nfunction getMonthLabels(weeks, monthNames = DEFAULT_MONTH_LABELS) {\n  return weeks.reduce((labels, week, weekIndex) => {\n    const firstActivity = week.find(activity => activity !== undefined);\n    if (!firstActivity) {\n      throw new Error(`Unexpected error: Week ${weekIndex + 1} is empty: [${week}].`);\n    }\n    const month = monthNames[dateFns.getMonth(dateFns.parseISO(firstActivity.date))];\n    const prevLabel = labels[labels.length - 1];\n    if (weekIndex === 0 || prevLabel.label !== month) {\n      return [...labels, {\n        weekIndex,\n        label: month\n      }];\n    }\n    return labels;\n  }, []).filter(({\n    weekIndex\n  }, index, labels) => {\n    // Labels should only be shown if there is \"enough\" space (data).\n    // This is a naive implementation that does not take the block size,\n    // font size etc. into account.\n    const minWeeks = 3;\n\n    // Skip the first month label if there is not enough space to the next one.\n    if (index === 0) {\n      return labels[1] && labels[1].weekIndex - weekIndex >= minWeeks;\n    }\n\n    // Skip the last month label the there is not enough data in that month to\n    // avoid overflowing the calendar on the right.\n    if (index === labels.length - 1) {\n      return weeks.slice(weekIndex).length >= minWeeks;\n    }\n    return true;\n  });\n}\nfunction getClassName(name, styles) {\n  if (styles) {\n    return `${NAMESPACE}__${name} ${styles}`;\n  }\n  return `${NAMESPACE}__${name}`;\n}\nfunction generateEmptyData() {\n  const year = new Date().getFullYear();\n  const days = dateFns.eachDayOfInterval({\n    start: new Date(year, 0, 1),\n    end: new Date(year, 11, 31)\n  });\n  return days.map(date => ({\n    date: dateFns.formatISO(date, {\n      representation: 'date'\n    }),\n    count: 0,\n    level: 0\n  }));\n}\nfunction maxWeekdayLabelLength(firstWeek, weekStart, labels, fontSize) {\n  return firstWeek.reduce((maxLength, _, index) => {\n    if (index % 2 !== 0) {\n      const dayIndex = (index + weekStart) % 7;\n      const curLength = Math.ceil(calcTextDimensions(labels[dayIndex], fontSize).width);\n      return Math.max(maxLength, curLength);\n    }\n    return maxLength;\n  }, 0);\n}\nfunction calcTextDimensions(text, fontSize) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('calcTextDimensions() requires browser APIs');\n  }\n  if (fontSize < 1) {\n    throw new RangeError('fontSize must be positive');\n  }\n  if (text.length === 0) {\n    return {\n      width: 0,\n      height: 0\n    };\n  }\n  const namespace = 'http://www.w3.org/2000/svg';\n  const svg = document.createElementNS(namespace, 'svg');\n  svg.style.position = 'absolute';\n  svg.style.visibility = 'hidden';\n  svg.style.fontFamily = window.getComputedStyle(document.body).fontFamily;\n  svg.style.fontSize = `${fontSize}px`;\n  const textNode = document.createElementNS(namespace, 'text');\n  textNode.textContent = text;\n  svg.appendChild(textNode);\n  document.body.appendChild(svg);\n  const boundingBox = textNode.getBBox();\n  document.body.removeChild(svg);\n  return {\n    width: boundingBox.width,\n    height: boundingBox.height\n  };\n}\n\nfunction createTheme(input, size = 5) {\n  const defaultTheme = createDefaultTheme(size);\n  if (input) {\n    validateTheme(input, size);\n    input.light = input.light ?? defaultTheme.light;\n    input.dark = input.dark ?? defaultTheme.dark;\n    return {\n      light: isColorScale(input.light, size) ? input.light : createColorScale(input.light, size),\n      dark: isColorScale(input.dark, size) ? input.dark : createColorScale(input.dark, size)\n    };\n  }\n  return defaultTheme;\n}\nfunction createDefaultTheme(size) {\n  return {\n    light: createColorScale(['hsl(0, 0%, 92%)', 'hsl(0, 0%, 26%)'], size),\n    dark: createColorScale(['hsl(0, 0%, 20%)', 'hsl(0, 0%, 92%)'], size)\n  };\n}\nfunction validateTheme(input, size) {\n  if (typeof input !== 'object' || input.light === undefined && input.dark === undefined) {\n    throw new Error(`The theme object must contain at least one of the fields \"light\" and \"dark\" with exactly 2 or ${size} colors respectively.`);\n  }\n  if (input.light) {\n    const {\n      length\n    } = input.light;\n    if (length !== 2 && length !== size) {\n      throw new Error(`theme.light must contain exactly 2 or ${size} colors, ${length} passed.`);\n    }\n  }\n  if (input.dark) {\n    const {\n      length\n    } = input.dark;\n    if (length !== 2 && length !== size) {\n      throw new Error(`theme.dark must contain exactly 2 or ${size} colors, ${length} passed.`);\n    }\n  }\n}\nfunction isColorScale(colors, size) {\n  const invalidColor = colors.find(color => !chroma__default.default.valid(color));\n  if (invalidColor) {\n    throw new Error(`Invalid color \"${invalidColor}\" passed. All CSS color formats are accepted.`);\n  }\n  return colors.length === size;\n}\nfunction createColorScale(colors, size) {\n  return chroma__default.default.scale(colors).mode('lch').colors(size);\n}\n\nconst ActivityCalendar = ({\n  data,\n  blockMargin = 4,\n  blockRadius = 2,\n  blockSize = 12,\n  colorScheme = undefined,\n  eventHandlers = {},\n  fontSize = 14,\n  hideColorLegend = false,\n  hideMonthLabels = false,\n  hideTotalCount = false,\n  labels: labelsProp = undefined,\n  maxLevel = 4,\n  loading = false,\n  renderBlock = undefined,\n  showWeekdayLabels = false,\n  style: styleProp = {},\n  theme: themeProp = undefined,\n  totalCount: totalCountProp = undefined,\n  weekStart = 0 // Sunday\n}) => {\n  maxLevel = Math.max(1, maxLevel);\n  const theme = createTheme(themeProp, maxLevel + 1);\n  const systemColorScheme = useColorScheme();\n  const colorScale = theme[colorScheme ?? systemColorScheme];\n  const useAnimation = !usePrefersReducedMotion();\n  if (loading) {\n    data = generateEmptyData();\n  }\n  if (data.length === 0) {\n    return null;\n  }\n  const year = dateFns.getYear(dateFns.parseISO(data[0]?.date));\n  const weeks = groupByWeeks(data, weekStart);\n  const labels = Object.assign({}, DEFAULT_LABELS, labelsProp);\n  const labelHeight = hideMonthLabels ? 0 : fontSize + LABEL_MARGIN;\n  const weekdayLabelOffset = showWeekdayLabels ? maxWeekdayLabelLength(weeks[0], weekStart, labels.weekdays, fontSize) + LABEL_MARGIN : undefined;\n  function getDimensions() {\n    return {\n      width: weeks.length * (blockSize + blockMargin) - blockMargin,\n      height: labelHeight + (blockSize + blockMargin) * 7 - blockMargin\n    };\n  }\n  function getEventHandlers(activity) {\n    return Object.keys(eventHandlers).reduce((handlers, key) => ({\n      ...handlers,\n      [key]: event => eventHandlers[key]?.(event)(activity)\n    }), {});\n  }\n  function renderCalendar() {\n    return weeks.map((week, weekIndex) => week.map((activity, dayIndex) => {\n      if (!activity) {\n        return null;\n      }\n      if (activity.level < 0 || activity.level > maxLevel) {\n        throw new RangeError(`Provided activity level ${activity.level} for ${activity.date} is out of range. It must be between 0 and ${maxLevel}.`);\n      }\n      const style = loading && useAnimation ? {\n        animation: `${styles.loadingAnimation} 1.75s ease-in-out infinite`,\n        animationDelay: `${weekIndex * 20 + dayIndex * 20}ms`\n      } : undefined;\n      const block = /*#__PURE__*/React__default.default.createElement(\"rect\", _extends({}, getEventHandlers(activity), {\n        x: 0,\n        y: labelHeight + (blockSize + blockMargin) * dayIndex,\n        width: blockSize,\n        height: blockSize,\n        rx: blockRadius,\n        ry: blockRadius,\n        fill: colorScale[activity.level],\n        \"data-date\": activity.date,\n        \"data-level\": activity.level,\n        style: style\n      }));\n      return /*#__PURE__*/React__default.default.createElement(React.Fragment, {\n        key: activity.date\n      }, renderBlock ? renderBlock(block, activity) : block);\n    })).map((week, x) => /*#__PURE__*/React__default.default.createElement(\"g\", {\n      key: x,\n      transform: `translate(${(blockSize + blockMargin) * x}, 0)`\n    }, week));\n  }\n  function renderFooter() {\n    if (hideTotalCount && hideColorLegend) {\n      return null;\n    }\n    const totalCount = typeof totalCountProp === 'number' ? totalCountProp : data.reduce((sum, activity) => sum + activity.count, 0);\n    return /*#__PURE__*/React__default.default.createElement(\"footer\", {\n      className: getClassName('footer', styles.footer),\n      style: {\n        marginLeft: weekdayLabelOffset\n      }\n    }, loading && /*#__PURE__*/React__default.default.createElement(\"div\", null, \"\\xA0\"), !loading && !hideTotalCount && /*#__PURE__*/React__default.default.createElement(\"div\", {\n      className: getClassName('count')\n    }, labels.totalCount ? labels.totalCount.replace('{{count}}', String(totalCount)).replace('{{year}}', String(year)) : `${totalCount} activities in ${year}`), !loading && !hideColorLegend && /*#__PURE__*/React__default.default.createElement(\"div\", {\n      className: getClassName('legend-colors', styles.legendColors)\n    }, /*#__PURE__*/React__default.default.createElement(\"span\", {\n      style: {\n        marginRight: '0.4em'\n      }\n    }, labels?.legend?.less ?? 'Less'), Array(maxLevel + 1).fill(undefined).map((_, level) => /*#__PURE__*/React__default.default.createElement(\"svg\", {\n      width: blockSize,\n      height: blockSize,\n      key: level\n    }, /*#__PURE__*/React__default.default.createElement(\"rect\", {\n      width: blockSize,\n      height: blockSize,\n      fill: colorScale[level],\n      rx: blockRadius,\n      ry: blockRadius\n    }))), /*#__PURE__*/React__default.default.createElement(\"span\", {\n      style: {\n        marginLeft: '0.4em'\n      }\n    }, labels?.legend?.more ?? 'More')));\n  }\n  function renderLabels() {\n    if (!showWeekdayLabels && hideMonthLabels) {\n      return null;\n    }\n    return /*#__PURE__*/React__default.default.createElement(React__default.default.Fragment, null, showWeekdayLabels && /*#__PURE__*/React__default.default.createElement(\"g\", {\n      className: getClassName('legend-weekday')\n    }, weeks[0].map((_, index) => {\n      if (index % 2 === 0) {\n        return null;\n      }\n      const dayIndex = (index + weekStart) % 7;\n      return /*#__PURE__*/React__default.default.createElement(\"text\", {\n        x: -LABEL_MARGIN,\n        y: labelHeight + (blockSize + blockMargin) * index + blockSize / 2,\n        dominantBaseline: \"middle\",\n        textAnchor: \"end\",\n        key: index\n      }, labels.weekdays[dayIndex]);\n    })), !hideMonthLabels && /*#__PURE__*/React__default.default.createElement(\"g\", {\n      className: getClassName('legend-month')\n    }, getMonthLabels(weeks, labels.months).map(({\n      label,\n      weekIndex\n    }) => /*#__PURE__*/React__default.default.createElement(\"text\", {\n      x: (blockSize + blockMargin) * weekIndex,\n      dominantBaseline: \"hanging\",\n      key: weekIndex\n    }, label))));\n  }\n  const {\n    width,\n    height\n  } = getDimensions();\n  const containerStyles = {\n    fontSize,\n    ...(useAnimation && {\n      [`--${NAMESPACE}-loading`]: colorScale[0],\n      [`--${NAMESPACE}-loading-active`]: colorScheme === 'light' ? chroma__default.default(colorScale[0]).darken(0.3).hex() : chroma__default.default(colorScale[0]).brighten(0.25).hex()\n    })\n  };\n  return /*#__PURE__*/React__default.default.createElement(\"article\", {\n    className: `${NAMESPACE} ${styles.container}`,\n    style: {\n      ...styleProp,\n      ...containerStyles\n    }\n  }, /*#__PURE__*/React__default.default.createElement(\"div\", {\n    className: getClassName('scroll-container', styles.scrollContainer)\n  }, /*#__PURE__*/React__default.default.createElement(\"svg\", {\n    width: width,\n    height: height,\n    viewBox: `0 0 ${width} ${height}`,\n    className: getClassName('calendar', styles.calendar),\n    style: {\n      marginLeft: weekdayLabelOffset\n    }\n  }, !loading && renderLabels(), renderCalendar())), renderFooter());\n};\nconst Skeleton = props => /*#__PURE__*/React__default.default.createElement(ActivityCalendar, _extends({\n  data: []\n}, props));\n\nexports.Skeleton = Skeleton;\nexports[\"default\"] = ActivityCalendar;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtYWN0aXZpdHktY2FsZW5kYXIvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGFBQWEsbUJBQU8sQ0FBQywyREFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsd0RBQVU7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQiwrQkFBK0IsaUNBQWlDOztBQUVoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVEsZ0JBQWdCLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELHdCQUF3QixtREFBbUQsdURBQXVELDJCQUEyQixhQUFhLEdBQUcsMENBQTBDLGdDQUFnQyxzQkFBc0Isd0NBQXdDLEdBQUcseUNBQXlDLDBDQUEwQyx3Q0FBd0MsS0FBSyxHQUFHLDJDQUEyQyxvQkFBb0IscUJBQXFCLHVCQUF1QixHQUFHLG9DQUFvQyxvQkFBb0IsNkRBQTZELDBEQUEw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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyxtREFBbUQsT0FBTyxrQ0FBa0MsTUFBTSxzQkFBc0IsWUFBWSxnQkFBZ0IsS0FBSztBQUM5SjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsRUFBRSxpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixPQUFPLEVBQUUsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdCQUFnQjtBQUNoQixrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFybG9uLWhpbm9yYW4vLi9ub2RlX21vZHVsZXMvcmVhY3QtYWN0aXZpdHktY2FsZW5kYXIvYnVpbGQvaW5kZXguanM/MjM4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjaHJvbWEgPSByZXF1aXJlKCdjaHJvbWEtanMnKTtcbnZhciBkYXRlRm5zID0gcmVxdWlyZSgnZGF0ZS1mbnMnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cblxudmFyIGNocm9tYV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoY2hyb21hKTtcbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoUmVhY3QpO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuY29uc3QgTkFNRVNQQUNFID0gJ3JlYWN0LWFjdGl2aXR5LWNhbGVuZGFyJztcbmNvbnN0IExBQkVMX01BUkdJTiA9IDg7IC8vIHB4XG5cbmNvbnN0IERFRkFVTFRfTU9OVEhfTEFCRUxTID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xuY29uc3QgREVGQVVMVF9MQUJFTFMgPSB7XG4gIG1vbnRoczogREVGQVVMVF9NT05USF9MQUJFTFMsXG4gIHdlZWtkYXlzOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICB0b3RhbENvdW50OiAne3tjb3VudH19IGFjdGl2aXRpZXMgaW4ge3t5ZWFyfX0nLFxuICBsZWdlbmQ6IHtcbiAgICBsZXNzOiAnTGVzcycsXG4gICAgbW9yZTogJ01vcmUnXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVzZUNvbG9yU2NoZW1lKCkge1xuICBjb25zdCBbY29sb3JTY2hlbWUsIHNldENvbG9yU2NoZW1lXSA9IFJlYWN0LnVzZVN0YXRlKCdsaWdodCcpO1xuICBjb25zdCBvbkNoYW5nZSA9IGV2ZW50ID0+IHNldENvbG9yU2NoZW1lKGV2ZW50Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKTtcbiAgICBzZXRDb2xvclNjaGVtZShtZWRpYVF1ZXJ5Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcbiAgICBtZWRpYVF1ZXJ5LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWVkaWFRdWVyeS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gY29sb3JTY2hlbWU7XG59XG5cbmNvbnN0IHF1ZXJ5ID0gJyhwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpJztcbmZ1bmN0aW9uIHVzZVByZWZlcnNSZWR1Y2VkTW90aW9uKCkge1xuICBjb25zdCBbcHJlZmVyc1JlZHVjZWRNb3Rpb24sIHNldFByZWZlcnNSZWR1Y2VkTW90aW9uXSA9IFJlYWN0LnVzZVN0YXRlKHRydWUpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShxdWVyeSk7XG4gICAgc2V0UHJlZmVyc1JlZHVjZWRNb3Rpb24obWVkaWFRdWVyeS5tYXRjaGVzKTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IGV2ZW50ID0+IHtcbiAgICAgIHNldFByZWZlcnNSZWR1Y2VkTW90aW9uKGV2ZW50Lm1hdGNoZXMpO1xuICAgIH07XG4gICAgbWVkaWFRdWVyeS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1lZGlhUXVlcnkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHByZWZlcnNSZWR1Y2VkTW90aW9uO1xufVxuXG5mdW5jdGlvbiBzdHlsZUluamVjdChjc3MsIHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gIHZhciBpbnNlcnRBdCA9IHJlZi5pbnNlcnRBdDtcblxuICBpZiAoIWNzcyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybjsgfVxuXG4gIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICBpZiAoaW5zZXJ0QXQgPT09ICd0b3AnKSB7XG4gICAgaWYgKGhlYWQuZmlyc3RDaGlsZCkge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBjc3NfMjQ4eiA9IFwiLnN0eWxlcy1tb2R1bGVfY29udGFpbmVyX19HQk54QyB7XFxuICB3aWR0aDogbWF4LWNvbnRlbnQ7IC8qIENhbGVuZGFyIHNob3VsZCBub3QgZ3JvdyAqL1xcbiAgbWF4LXdpZHRoOiAxMDAlOyAvKiBEbyBub3QgcmVtb3ZlIC0gZmxleGJveCBwYXJlbnRzICovXFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGdhcDogOHB4O1xcbn1cXG5cXG4uc3R5bGVzLW1vZHVsZV9jb250YWluZXJfX0dCTnhDIHJlY3Qge1xcbiAgc3Ryb2tlOiByZ2JhKDAsIDAsIDAsIDAuMDgpO1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7XFxuICBzaGFwZS1yZW5kZXJpbmc6IGdlb21ldHJpY1ByZWNpc2lvbjtcXG59XFxuXFxuQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykge1xcbiAgLnN0eWxlcy1tb2R1bGVfY29udGFpbmVyX19HQk54QyByZWN0IHtcXG4gICAgc3Ryb2tlOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDQpO1xcbiAgfVxcbn1cXG5cXG4uc3R5bGVzLW1vZHVsZV9zY3JvbGxDb250YWluZXJfXy1iSkM4IHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIG92ZXJmbG93LXg6IGF1dG87XFxuICBvdmVyZmxvdy15OiBoaWRkZW47XFxufVxcblxcbi5zdHlsZXMtbW9kdWxlX2NhbGVuZGFyX19zVDFORCB7XFxuICBkaXNwbGF5OiBibG9jazsgLyogU1ZHcyBhcmUgaW5saW5lLWJsb2NrIGJ5IGRlZmF1bHQgKi9cXG4gIG92ZXJmbG93OiB2aXNpYmxlOyAvKiBXZWVrZGF5IGxhYmVscyBhcmUgcmVuZGVyZWQgbGVmdCBvZiB0aGUgY29udGFpbmVyICovXFxufVxcblxcbi5zdHlsZXMtbW9kdWxlX2NhbGVuZGFyX19zVDFORCB0ZXh0IHtcXG4gIGZpbGw6IGN1cnJlbnRDb2xvcjtcXG59XFxuXFxuLnN0eWxlcy1tb2R1bGVfZm9vdGVyX19aUS1CbCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbiAgZ2FwOiA0cHggMTZweDtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcbi5zdHlsZXMtbW9kdWxlX2xlZ2VuZENvbG9yc19fa0ZZMmUge1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGdhcDogM3B4O1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIHN0eWxlcy1tb2R1bGVfbG9hZGluZ0FuaW1hdGlvbl9fVjB3M2gge1xcbiAgMCUge1xcbiAgICBmaWxsOiB2YXIoLS1yZWFjdC1hY3Rpdml0eS1jYWxlbmRhci1sb2FkaW5nKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIGZpbGw6IHZhcigtLXJlYWN0LWFjdGl2aXR5LWNhbGVuZGFyLWxvYWRpbmctYWN0aXZlKTtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICBmaWxsOiB2YXIoLS1yZWFjdC1hY3Rpdml0eS1jYWxlbmRhci1sb2FkaW5nKTtcXG4gIH1cXG59XFxuXCI7XG52YXIgc3R5bGVzID0ge1wiY29udGFpbmVyXCI6XCJzdHlsZXMtbW9kdWxlX2NvbnRhaW5lcl9fR0JOeENcIixcInNjcm9sbENvbnRhaW5lclwiOlwic3R5bGVzLW1vZHVsZV9zY3JvbGxDb250YWluZXJfXy1iSkM4XCIsXCJjYWxlbmRhclwiOlwic3R5bGVzLW1vZHVsZV9jYWxlbmRhcl9fc1QxTkRcIixcImZvb3RlclwiOlwic3R5bGVzLW1vZHVsZV9mb290ZXJfX1pRLUJsXCIsXCJsZWdlbmRDb2xvcnNcIjpcInN0eWxlcy1tb2R1bGVfbGVnZW5kQ29sb3JzX19rRlkyZVwiLFwibG9hZGluZ0FuaW1hdGlvblwiOlwic3R5bGVzLW1vZHVsZV9sb2FkaW5nQW5pbWF0aW9uX19WMHczaFwifTtcbnN0eWxlSW5qZWN0KGNzc18yNDh6KTtcblxuZnVuY3Rpb24gZ3JvdXBCeVdlZWtzKGFjdGl2aXRpZXMsIHdlZWtTdGFydCA9IDAgLy8gMCA9IFN1bmRheVxuKSB7XG4gIGlmIChhY3Rpdml0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkQWN0aXZpdGllcyA9IGZpbGxIb2xlcyhhY3Rpdml0aWVzKTtcblxuICAvLyBEZXRlcm1pbmUgdGhlIGZpcnN0IGRhdGUgb2YgdGhlIGNhbGVuZGFyLiBJZiB0aGUgZmlyc3QgZGF0ZSBpcyBub3QgdGhlXG4gIC8vIHNldCBzdGFydCB3ZWVrZGF5LCB0aGUgc2VsZWN0ZWQgd2Vla2RheSBvbmUgd2VlayBlYXJsaWVyIGlzIHVzZWQuXG4gIGNvbnN0IGZpcnN0RGF0ZSA9IGRhdGVGbnMucGFyc2VJU08obm9ybWFsaXplZEFjdGl2aXRpZXNbMF0uZGF0ZSk7XG4gIGNvbnN0IGZpcnN0Q2FsZW5kYXJEYXRlID0gZGF0ZUZucy5nZXREYXkoZmlyc3REYXRlKSA9PT0gd2Vla1N0YXJ0ID8gZmlyc3REYXRlIDogZGF0ZUZucy5zdWJXZWVrcyhkYXRlRm5zLm5leHREYXkoZmlyc3REYXRlLCB3ZWVrU3RhcnQpLCAxKTtcblxuICAvLyBUbyBjb3JyZWN0bHkgZ3JvdXAgYWN0aXZpdGllcyBieSB3ZWVrLCBpdCBpcyBuZWNlc3NhcnkgdG8gbGVmdC1wYWQgdGhlIGxpc3RcbiAgLy8gYmVjYXVzZSB0aGUgZmlyc3QgZGF0ZSBtaWdodCBub3QgYmUgc2V0IHN0YXJ0IHdlZWtkYXkuXG4gIGNvbnN0IHBhZGRlZEFjdGl2aXRpZXMgPSBbLi4uQXJyYXkoZGF0ZUZucy5kaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoZmlyc3REYXRlLCBmaXJzdENhbGVuZGFyRGF0ZSkpLmZpbGwodW5kZWZpbmVkKSwgLi4ubm9ybWFsaXplZEFjdGl2aXRpZXNdO1xuICBjb25zdCBudW1iZXJPZldlZWtzID0gTWF0aC5jZWlsKHBhZGRlZEFjdGl2aXRpZXMubGVuZ3RoIC8gNyk7XG5cbiAgLy8gRmluYWxseSwgZ3JvdXAgYWN0aXZpdGllcyBieSB3ZWVrXG4gIHJldHVybiBBcnJheShudW1iZXJPZldlZWtzKS5maWxsKHVuZGVmaW5lZCkubWFwKChfLCB3ZWVrSW5kZXgpID0+IHBhZGRlZEFjdGl2aXRpZXMuc2xpY2Uod2Vla0luZGV4ICogNywgd2Vla0luZGV4ICogNyArIDcpKTtcbn1cblxuLyoqXG4gKiBUaGUgY2FsZW5kYXIgZXhwZWN0cyBhIGNvbnRpbnVvdXMgc2VxdWVuY2Ugb2YgZGF5cyxcbiAqIHNvIGZpbGwgZ2FwcyB3aXRoIGVtcHR5IGFjdGl2aXR5IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGZpbGxIb2xlcyhhY3Rpdml0aWVzKSB7XG4gIGNvbnN0IGRhdGVNYXAgPSB7fTtcbiAgZm9yIChjb25zdCBhY3Rpdml0eSBvZiBhY3Rpdml0aWVzKSB7XG4gICAgZGF0ZU1hcFthY3Rpdml0eS5kYXRlXSA9IGFjdGl2aXR5O1xuICB9XG4gIHJldHVybiBkYXRlRm5zLmVhY2hEYXlPZkludGVydmFsKHtcbiAgICBzdGFydDogZGF0ZUZucy5wYXJzZUlTTyhhY3Rpdml0aWVzWzBdLmRhdGUpLFxuICAgIGVuZDogZGF0ZUZucy5wYXJzZUlTTyhhY3Rpdml0aWVzW2FjdGl2aXRpZXMubGVuZ3RoIC0gMV0uZGF0ZSlcbiAgfSkubWFwKGRheSA9PiB7XG4gICAgY29uc3QgZGF0ZSA9IGRhdGVGbnMuZm9ybWF0SVNPKGRheSwge1xuICAgICAgcmVwcmVzZW50YXRpb246ICdkYXRlJ1xuICAgIH0pO1xuICAgIGlmIChkYXRlTWFwW2RhdGVdKSB7XG4gICAgICByZXR1cm4gZGF0ZU1hcFtkYXRlXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGUsXG4gICAgICBjb3VudDogMCxcbiAgICAgIGxldmVsOiAwXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRNb250aExhYmVscyh3ZWVrcywgbW9udGhOYW1lcyA9IERFRkFVTFRfTU9OVEhfTEFCRUxTKSB7XG4gIHJldHVybiB3ZWVrcy5yZWR1Y2UoKGxhYmVscywgd2Vlaywgd2Vla0luZGV4KSA9PiB7XG4gICAgY29uc3QgZmlyc3RBY3Rpdml0eSA9IHdlZWsuZmluZChhY3Rpdml0eSA9PiBhY3Rpdml0eSAhPT0gdW5kZWZpbmVkKTtcbiAgICBpZiAoIWZpcnN0QWN0aXZpdHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBlcnJvcjogV2VlayAke3dlZWtJbmRleCArIDF9IGlzIGVtcHR5OiBbJHt3ZWVrfV0uYCk7XG4gICAgfVxuICAgIGNvbnN0IG1vbnRoID0gbW9udGhOYW1lc1tkYXRlRm5zLmdldE1vbnRoKGRhdGVGbnMucGFyc2VJU08oZmlyc3RBY3Rpdml0eS5kYXRlKSldO1xuICAgIGNvbnN0IHByZXZMYWJlbCA9IGxhYmVsc1tsYWJlbHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHdlZWtJbmRleCA9PT0gMCB8fCBwcmV2TGFiZWwubGFiZWwgIT09IG1vbnRoKSB7XG4gICAgICByZXR1cm4gWy4uLmxhYmVscywge1xuICAgICAgICB3ZWVrSW5kZXgsXG4gICAgICAgIGxhYmVsOiBtb250aFxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBsYWJlbHM7XG4gIH0sIFtdKS5maWx0ZXIoKHtcbiAgICB3ZWVrSW5kZXhcbiAgfSwgaW5kZXgsIGxhYmVscykgPT4ge1xuICAgIC8vIExhYmVscyBzaG91bGQgb25seSBiZSBzaG93biBpZiB0aGVyZSBpcyBcImVub3VnaFwiIHNwYWNlIChkYXRhKS5cbiAgICAvLyBUaGlzIGlzIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gdGhhdCBkb2VzIG5vdCB0YWtlIHRoZSBibG9jayBzaXplLFxuICAgIC8vIGZvbnQgc2l6ZSBldGMuIGludG8gYWNjb3VudC5cbiAgICBjb25zdCBtaW5XZWVrcyA9IDM7XG5cbiAgICAvLyBTa2lwIHRoZSBmaXJzdCBtb250aCBsYWJlbCBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIHRvIHRoZSBuZXh0IG9uZS5cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBsYWJlbHNbMV0gJiYgbGFiZWxzWzFdLndlZWtJbmRleCAtIHdlZWtJbmRleCA+PSBtaW5XZWVrcztcbiAgICB9XG5cbiAgICAvLyBTa2lwIHRoZSBsYXN0IG1vbnRoIGxhYmVsIHRoZSB0aGVyZSBpcyBub3QgZW5vdWdoIGRhdGEgaW4gdGhhdCBtb250aCB0b1xuICAgIC8vIGF2b2lkIG92ZXJmbG93aW5nIHRoZSBjYWxlbmRhciBvbiB0aGUgcmlnaHQuXG4gICAgaWYgKGluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIHdlZWtzLnNsaWNlKHdlZWtJbmRleCkubGVuZ3RoID49IG1pbldlZWtzO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDbGFzc05hbWUobmFtZSwgc3R5bGVzKSB7XG4gIGlmIChzdHlsZXMpIHtcbiAgICByZXR1cm4gYCR7TkFNRVNQQUNFfV9fJHtuYW1lfSAke3N0eWxlc31gO1xuICB9XG4gIHJldHVybiBgJHtOQU1FU1BBQ0V9X18ke25hbWV9YDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlRW1wdHlEYXRhKCkge1xuICBjb25zdCB5ZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBkYXlzID0gZGF0ZUZucy5lYWNoRGF5T2ZJbnRlcnZhbCh7XG4gICAgc3RhcnQ6IG5ldyBEYXRlKHllYXIsIDAsIDEpLFxuICAgIGVuZDogbmV3IERhdGUoeWVhciwgMTEsIDMxKVxuICB9KTtcbiAgcmV0dXJuIGRheXMubWFwKGRhdGUgPT4gKHtcbiAgICBkYXRlOiBkYXRlRm5zLmZvcm1hdElTTyhkYXRlLCB7XG4gICAgICByZXByZXNlbnRhdGlvbjogJ2RhdGUnXG4gICAgfSksXG4gICAgY291bnQ6IDAsXG4gICAgbGV2ZWw6IDBcbiAgfSkpO1xufVxuZnVuY3Rpb24gbWF4V2Vla2RheUxhYmVsTGVuZ3RoKGZpcnN0V2Vlaywgd2Vla1N0YXJ0LCBsYWJlbHMsIGZvbnRTaXplKSB7XG4gIHJldHVybiBmaXJzdFdlZWsucmVkdWNlKChtYXhMZW5ndGgsIF8sIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ICUgMiAhPT0gMCkge1xuICAgICAgY29uc3QgZGF5SW5kZXggPSAoaW5kZXggKyB3ZWVrU3RhcnQpICUgNztcbiAgICAgIGNvbnN0IGN1ckxlbmd0aCA9IE1hdGguY2VpbChjYWxjVGV4dERpbWVuc2lvbnMobGFiZWxzW2RheUluZGV4XSwgZm9udFNpemUpLndpZHRoKTtcbiAgICAgIHJldHVybiBNYXRoLm1heChtYXhMZW5ndGgsIGN1ckxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBtYXhMZW5ndGg7XG4gIH0sIDApO1xufVxuZnVuY3Rpb24gY2FsY1RleHREaW1lbnNpb25zKHRleHQsIGZvbnRTaXplKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxjVGV4dERpbWVuc2lvbnMoKSByZXF1aXJlcyBicm93c2VyIEFQSXMnKTtcbiAgfVxuICBpZiAoZm9udFNpemUgPCAxKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ZvbnRTaXplIG11c3QgYmUgcG9zaXRpdmUnKTtcbiAgfVxuICBpZiAodGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICB9XG4gIGNvbnN0IG5hbWVzcGFjZSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsICdzdmcnKTtcbiAgc3ZnLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgc3ZnLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgc3ZnLnN0eWxlLmZvbnRGYW1pbHkgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5mb250RmFtaWx5O1xuICBzdmcuc3R5bGUuZm9udFNpemUgPSBgJHtmb250U2l6ZX1weGA7XG4gIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgJ3RleHQnKTtcbiAgdGV4dE5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICBzdmcuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN2Zyk7XG4gIGNvbnN0IGJvdW5kaW5nQm94ID0gdGV4dE5vZGUuZ2V0QkJveCgpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHN2Zyk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGJvdW5kaW5nQm94LndpZHRoLFxuICAgIGhlaWdodDogYm91bmRpbmdCb3guaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRoZW1lKGlucHV0LCBzaXplID0gNSkge1xuICBjb25zdCBkZWZhdWx0VGhlbWUgPSBjcmVhdGVEZWZhdWx0VGhlbWUoc2l6ZSk7XG4gIGlmIChpbnB1dCkge1xuICAgIHZhbGlkYXRlVGhlbWUoaW5wdXQsIHNpemUpO1xuICAgIGlucHV0LmxpZ2h0ID0gaW5wdXQubGlnaHQgPz8gZGVmYXVsdFRoZW1lLmxpZ2h0O1xuICAgIGlucHV0LmRhcmsgPSBpbnB1dC5kYXJrID8/IGRlZmF1bHRUaGVtZS5kYXJrO1xuICAgIHJldHVybiB7XG4gICAgICBsaWdodDogaXNDb2xvclNjYWxlKGlucHV0LmxpZ2h0LCBzaXplKSA/IGlucHV0LmxpZ2h0IDogY3JlYXRlQ29sb3JTY2FsZShpbnB1dC5saWdodCwgc2l6ZSksXG4gICAgICBkYXJrOiBpc0NvbG9yU2NhbGUoaW5wdXQuZGFyaywgc2l6ZSkgPyBpbnB1dC5kYXJrIDogY3JlYXRlQ29sb3JTY2FsZShpbnB1dC5kYXJrLCBzaXplKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRUaGVtZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRUaGVtZShzaXplKSB7XG4gIHJldHVybiB7XG4gICAgbGlnaHQ6IGNyZWF0ZUNvbG9yU2NhbGUoWydoc2woMCwgMCUsIDkyJSknLCAnaHNsKDAsIDAlLCAyNiUpJ10sIHNpemUpLFxuICAgIGRhcms6IGNyZWF0ZUNvbG9yU2NhbGUoWydoc2woMCwgMCUsIDIwJSknLCAnaHNsKDAsIDAlLCA5MiUpJ10sIHNpemUpXG4gIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVRoZW1lKGlucHV0LCBzaXplKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnIHx8IGlucHV0LmxpZ2h0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQuZGFyayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdGhlbWUgb2JqZWN0IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZpZWxkcyBcImxpZ2h0XCIgYW5kIFwiZGFya1wiIHdpdGggZXhhY3RseSAyIG9yICR7c2l6ZX0gY29sb3JzIHJlc3BlY3RpdmVseS5gKTtcbiAgfVxuICBpZiAoaW5wdXQubGlnaHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGhcbiAgICB9ID0gaW5wdXQubGlnaHQ7XG4gICAgaWYgKGxlbmd0aCAhPT0gMiAmJiBsZW5ndGggIT09IHNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdGhlbWUubGlnaHQgbXVzdCBjb250YWluIGV4YWN0bHkgMiBvciAke3NpemV9IGNvbG9ycywgJHtsZW5ndGh9IHBhc3NlZC5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlucHV0LmRhcmspIHtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGhcbiAgICB9ID0gaW5wdXQuZGFyaztcbiAgICBpZiAobGVuZ3RoICE9PSAyICYmIGxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0aGVtZS5kYXJrIG11c3QgY29udGFpbiBleGFjdGx5IDIgb3IgJHtzaXplfSBjb2xvcnMsICR7bGVuZ3RofSBwYXNzZWQuYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0NvbG9yU2NhbGUoY29sb3JzLCBzaXplKSB7XG4gIGNvbnN0IGludmFsaWRDb2xvciA9IGNvbG9ycy5maW5kKGNvbG9yID0+ICFjaHJvbWFfX2RlZmF1bHQuZGVmYXVsdC52YWxpZChjb2xvcikpO1xuICBpZiAoaW52YWxpZENvbG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbG9yIFwiJHtpbnZhbGlkQ29sb3J9XCIgcGFzc2VkLiBBbGwgQ1NTIGNvbG9yIGZvcm1hdHMgYXJlIGFjY2VwdGVkLmApO1xuICB9XG4gIHJldHVybiBjb2xvcnMubGVuZ3RoID09PSBzaXplO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29sb3JTY2FsZShjb2xvcnMsIHNpemUpIHtcbiAgcmV0dXJuIGNocm9tYV9fZGVmYXVsdC5kZWZhdWx0LnNjYWxlKGNvbG9ycykubW9kZSgnbGNoJykuY29sb3JzKHNpemUpO1xufVxuXG5jb25zdCBBY3Rpdml0eUNhbGVuZGFyID0gKHtcbiAgZGF0YSxcbiAgYmxvY2tNYXJnaW4gPSA0LFxuICBibG9ja1JhZGl1cyA9IDIsXG4gIGJsb2NrU2l6ZSA9IDEyLFxuICBjb2xvclNjaGVtZSA9IHVuZGVmaW5lZCxcbiAgZXZlbnRIYW5kbGVycyA9IHt9LFxuICBmb250U2l6ZSA9IDE0LFxuICBoaWRlQ29sb3JMZWdlbmQgPSBmYWxzZSxcbiAgaGlkZU1vbnRoTGFiZWxzID0gZmFsc2UsXG4gIGhpZGVUb3RhbENvdW50ID0gZmFsc2UsXG4gIGxhYmVsczogbGFiZWxzUHJvcCA9IHVuZGVmaW5lZCxcbiAgbWF4TGV2ZWwgPSA0LFxuICBsb2FkaW5nID0gZmFsc2UsXG4gIHJlbmRlckJsb2NrID0gdW5kZWZpbmVkLFxuICBzaG93V2Vla2RheUxhYmVscyA9IGZhbHNlLFxuICBzdHlsZTogc3R5bGVQcm9wID0ge30sXG4gIHRoZW1lOiB0aGVtZVByb3AgPSB1bmRlZmluZWQsXG4gIHRvdGFsQ291bnQ6IHRvdGFsQ291bnRQcm9wID0gdW5kZWZpbmVkLFxuICB3ZWVrU3RhcnQgPSAwIC8vIFN1bmRheVxufSkgPT4ge1xuICBtYXhMZXZlbCA9IE1hdGgubWF4KDEsIG1heExldmVsKTtcbiAgY29uc3QgdGhlbWUgPSBjcmVhdGVUaGVtZSh0aGVtZVByb3AsIG1heExldmVsICsgMSk7XG4gIGNvbnN0IHN5c3RlbUNvbG9yU2NoZW1lID0gdXNlQ29sb3JTY2hlbWUoKTtcbiAgY29uc3QgY29sb3JTY2FsZSA9IHRoZW1lW2NvbG9yU2NoZW1lID8/IHN5c3RlbUNvbG9yU2NoZW1lXTtcbiAgY29uc3QgdXNlQW5pbWF0aW9uID0gIXVzZVByZWZlcnNSZWR1Y2VkTW90aW9uKCk7XG4gIGlmIChsb2FkaW5nKSB7XG4gICAgZGF0YSA9IGdlbmVyYXRlRW1wdHlEYXRhKCk7XG4gIH1cbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgeWVhciA9IGRhdGVGbnMuZ2V0WWVhcihkYXRlRm5zLnBhcnNlSVNPKGRhdGFbMF0/LmRhdGUpKTtcbiAgY29uc3Qgd2Vla3MgPSBncm91cEJ5V2Vla3MoZGF0YSwgd2Vla1N0YXJ0KTtcbiAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9MQUJFTFMsIGxhYmVsc1Byb3ApO1xuICBjb25zdCBsYWJlbEhlaWdodCA9IGhpZGVNb250aExhYmVscyA/IDAgOiBmb250U2l6ZSArIExBQkVMX01BUkdJTjtcbiAgY29uc3Qgd2Vla2RheUxhYmVsT2Zmc2V0ID0gc2hvd1dlZWtkYXlMYWJlbHMgPyBtYXhXZWVrZGF5TGFiZWxMZW5ndGgod2Vla3NbMF0sIHdlZWtTdGFydCwgbGFiZWxzLndlZWtkYXlzLCBmb250U2l6ZSkgKyBMQUJFTF9NQVJHSU4gOiB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3ZWVrcy5sZW5ndGggKiAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pIC0gYmxvY2tNYXJnaW4sXG4gICAgICBoZWlnaHQ6IGxhYmVsSGVpZ2h0ICsgKGJsb2NrU2l6ZSArIGJsb2NrTWFyZ2luKSAqIDcgLSBibG9ja01hcmdpblxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RXZlbnRIYW5kbGVycyhhY3Rpdml0eSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhldmVudEhhbmRsZXJzKS5yZWR1Y2UoKGhhbmRsZXJzLCBrZXkpID0+ICh7XG4gICAgICAuLi5oYW5kbGVycyxcbiAgICAgIFtrZXldOiBldmVudCA9PiBldmVudEhhbmRsZXJzW2tleV0/LihldmVudCkoYWN0aXZpdHkpXG4gICAgfSksIHt9KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gd2Vla3MubWFwKCh3ZWVrLCB3ZWVrSW5kZXgpID0+IHdlZWsubWFwKChhY3Rpdml0eSwgZGF5SW5kZXgpID0+IHtcbiAgICAgIGlmICghYWN0aXZpdHkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZpdHkubGV2ZWwgPCAwIHx8IGFjdGl2aXR5LmxldmVsID4gbWF4TGV2ZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFByb3ZpZGVkIGFjdGl2aXR5IGxldmVsICR7YWN0aXZpdHkubGV2ZWx9IGZvciAke2FjdGl2aXR5LmRhdGV9IGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kICR7bWF4TGV2ZWx9LmApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3R5bGUgPSBsb2FkaW5nICYmIHVzZUFuaW1hdGlvbiA/IHtcbiAgICAgICAgYW5pbWF0aW9uOiBgJHtzdHlsZXMubG9hZGluZ0FuaW1hdGlvbn0gMS43NXMgZWFzZS1pbi1vdXQgaW5maW5pdGVgLFxuICAgICAgICBhbmltYXRpb25EZWxheTogYCR7d2Vla0luZGV4ICogMjAgKyBkYXlJbmRleCAqIDIwfW1zYFxuICAgICAgfSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGJsb2NrID0gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInJlY3RcIiwgX2V4dGVuZHMoe30sIGdldEV2ZW50SGFuZGxlcnMoYWN0aXZpdHkpLCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IGxhYmVsSGVpZ2h0ICsgKGJsb2NrU2l6ZSArIGJsb2NrTWFyZ2luKSAqIGRheUluZGV4LFxuICAgICAgICB3aWR0aDogYmxvY2tTaXplLFxuICAgICAgICBoZWlnaHQ6IGJsb2NrU2l6ZSxcbiAgICAgICAgcng6IGJsb2NrUmFkaXVzLFxuICAgICAgICByeTogYmxvY2tSYWRpdXMsXG4gICAgICAgIGZpbGw6IGNvbG9yU2NhbGVbYWN0aXZpdHkubGV2ZWxdLFxuICAgICAgICBcImRhdGEtZGF0ZVwiOiBhY3Rpdml0eS5kYXRlLFxuICAgICAgICBcImRhdGEtbGV2ZWxcIjogYWN0aXZpdHkubGV2ZWwsXG4gICAgICAgIHN0eWxlOiBzdHlsZVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIHtcbiAgICAgICAga2V5OiBhY3Rpdml0eS5kYXRlXG4gICAgICB9LCByZW5kZXJCbG9jayA/IHJlbmRlckJsb2NrKGJsb2NrLCBhY3Rpdml0eSkgOiBibG9jayk7XG4gICAgfSkpLm1hcCgod2VlaywgeCkgPT4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgICAga2V5OiB4LFxuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7KGJsb2NrU2l6ZSArIGJsb2NrTWFyZ2luKSAqIHh9LCAwKWBcbiAgICB9LCB3ZWVrKSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyRm9vdGVyKCkge1xuICAgIGlmIChoaWRlVG90YWxDb3VudCAmJiBoaWRlQ29sb3JMZWdlbmQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0b3RhbENvdW50ID0gdHlwZW9mIHRvdGFsQ291bnRQcm9wID09PSAnbnVtYmVyJyA/IHRvdGFsQ291bnRQcm9wIDogZGF0YS5yZWR1Y2UoKHN1bSwgYWN0aXZpdHkpID0+IHN1bSArIGFjdGl2aXR5LmNvdW50LCAwKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImZvb3RlclwiLCB7XG4gICAgICBjbGFzc05hbWU6IGdldENsYXNzTmFtZSgnZm9vdGVyJywgc3R5bGVzLmZvb3RlciksXG4gICAgICBzdHlsZToge1xuICAgICAgICBtYXJnaW5MZWZ0OiB3ZWVrZGF5TGFiZWxPZmZzZXRcbiAgICAgIH1cbiAgICB9LCBsb2FkaW5nICYmIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXCJcXHhBMFwiKSwgIWxvYWRpbmcgJiYgIWhpZGVUb3RhbENvdW50ICYmIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBnZXRDbGFzc05hbWUoJ2NvdW50JylcbiAgICB9LCBsYWJlbHMudG90YWxDb3VudCA/IGxhYmVscy50b3RhbENvdW50LnJlcGxhY2UoJ3t7Y291bnR9fScsIFN0cmluZyh0b3RhbENvdW50KSkucmVwbGFjZSgne3t5ZWFyfX0nLCBTdHJpbmcoeWVhcikpIDogYCR7dG90YWxDb3VudH0gYWN0aXZpdGllcyBpbiAke3llYXJ9YCksICFsb2FkaW5nICYmICFoaWRlQ29sb3JMZWdlbmQgJiYgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IGdldENsYXNzTmFtZSgnbGVnZW5kLWNvbG9ycycsIHN0eWxlcy5sZWdlbmRDb2xvcnMpXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgbWFyZ2luUmlnaHQ6ICcwLjRlbSdcbiAgICAgIH1cbiAgICB9LCBsYWJlbHM/LmxlZ2VuZD8ubGVzcyA/PyAnTGVzcycpLCBBcnJheShtYXhMZXZlbCArIDEpLmZpbGwodW5kZWZpbmVkKS5tYXAoKF8sIGxldmVsKSA9PiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgIHdpZHRoOiBibG9ja1NpemUsXG4gICAgICBoZWlnaHQ6IGJsb2NrU2l6ZSxcbiAgICAgIGtleTogbGV2ZWxcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICB3aWR0aDogYmxvY2tTaXplLFxuICAgICAgaGVpZ2h0OiBibG9ja1NpemUsXG4gICAgICBmaWxsOiBjb2xvclNjYWxlW2xldmVsXSxcbiAgICAgIHJ4OiBibG9ja1JhZGl1cyxcbiAgICAgIHJ5OiBibG9ja1JhZGl1c1xuICAgIH0pKSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6ICcwLjRlbSdcbiAgICAgIH1cbiAgICB9LCBsYWJlbHM/LmxlZ2VuZD8ubW9yZSA/PyAnTW9yZScpKSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyTGFiZWxzKCkge1xuICAgIGlmICghc2hvd1dlZWtkYXlMYWJlbHMgJiYgaGlkZU1vbnRoTGFiZWxzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgc2hvd1dlZWtkYXlMYWJlbHMgJiYgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgICAgY2xhc3NOYW1lOiBnZXRDbGFzc05hbWUoJ2xlZ2VuZC13ZWVrZGF5JylcbiAgICB9LCB3ZWVrc1swXS5tYXAoKF8sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF5SW5kZXggPSAoaW5kZXggKyB3ZWVrU3RhcnQpICUgNztcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwidGV4dFwiLCB7XG4gICAgICAgIHg6IC1MQUJFTF9NQVJHSU4sXG4gICAgICAgIHk6IGxhYmVsSGVpZ2h0ICsgKGJsb2NrU2l6ZSArIGJsb2NrTWFyZ2luKSAqIGluZGV4ICsgYmxvY2tTaXplIC8gMixcbiAgICAgICAgZG9taW5hbnRCYXNlbGluZTogXCJtaWRkbGVcIixcbiAgICAgICAgdGV4dEFuY2hvcjogXCJlbmRcIixcbiAgICAgICAga2V5OiBpbmRleFxuICAgICAgfSwgbGFiZWxzLndlZWtkYXlzW2RheUluZGV4XSk7XG4gICAgfSkpLCAhaGlkZU1vbnRoTGFiZWxzICYmIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lKCdsZWdlbmQtbW9udGgnKVxuICAgIH0sIGdldE1vbnRoTGFiZWxzKHdlZWtzLCBsYWJlbHMubW9udGhzKS5tYXAoKHtcbiAgICAgIGxhYmVsLFxuICAgICAgd2Vla0luZGV4XG4gICAgfSkgPT4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInRleHRcIiwge1xuICAgICAgeDogKGJsb2NrU2l6ZSArIGJsb2NrTWFyZ2luKSAqIHdlZWtJbmRleCxcbiAgICAgIGRvbWluYW50QmFzZWxpbmU6IFwiaGFuZ2luZ1wiLFxuICAgICAga2V5OiB3ZWVrSW5kZXhcbiAgICB9LCBsYWJlbCkpKSk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gZ2V0RGltZW5zaW9ucygpO1xuICBjb25zdCBjb250YWluZXJTdHlsZXMgPSB7XG4gICAgZm9udFNpemUsXG4gICAgLi4uKHVzZUFuaW1hdGlvbiAmJiB7XG4gICAgICBbYC0tJHtOQU1FU1BBQ0V9LWxvYWRpbmdgXTogY29sb3JTY2FsZVswXSxcbiAgICAgIFtgLS0ke05BTUVTUEFDRX0tbG9hZGluZy1hY3RpdmVgXTogY29sb3JTY2hlbWUgPT09ICdsaWdodCcgPyBjaHJvbWFfX2RlZmF1bHQuZGVmYXVsdChjb2xvclNjYWxlWzBdKS5kYXJrZW4oMC4zKS5oZXgoKSA6IGNocm9tYV9fZGVmYXVsdC5kZWZhdWx0KGNvbG9yU2NhbGVbMF0pLmJyaWdodGVuKDAuMjUpLmhleCgpXG4gICAgfSlcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJhcnRpY2xlXCIsIHtcbiAgICBjbGFzc05hbWU6IGAke05BTUVTUEFDRX0gJHtzdHlsZXMuY29udGFpbmVyfWAsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlUHJvcCxcbiAgICAgIC4uLmNvbnRhaW5lclN0eWxlc1xuICAgIH1cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBnZXRDbGFzc05hbWUoJ3Njcm9sbC1jb250YWluZXInLCBzdHlsZXMuc2Nyb2xsQ29udGFpbmVyKVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdmlld0JveDogYDAgMCAke3dpZHRofSAke2hlaWdodH1gLFxuICAgIGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lKCdjYWxlbmRhcicsIHN0eWxlcy5jYWxlbmRhciksXG4gICAgc3R5bGU6IHtcbiAgICAgIG1hcmdpbkxlZnQ6IHdlZWtkYXlMYWJlbE9mZnNldFxuICAgIH1cbiAgfSwgIWxvYWRpbmcgJiYgcmVuZGVyTGFiZWxzKCksIHJlbmRlckNhbGVuZGFyKCkpKSwgcmVuZGVyRm9vdGVyKCkpO1xufTtcbmNvbnN0IFNrZWxldG9uID0gcHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBY3Rpdml0eUNhbGVuZGFyLCBfZXh0ZW5kcyh7XG4gIGRhdGE6IFtdXG59LCBwcm9wcykpO1xuXG5leHBvcnRzLlNrZWxldG9uID0gU2tlbGV0b247XG5leHBvcnRzLmRlZmF1bHQgPSBBY3Rpdml0eUNhbGVuZGFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-activity-calendar/build/index.js\n");

/***/ })

};
;